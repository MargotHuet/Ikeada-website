//---> DEBUT ROOTING BO

// Check en premier si jeton JWT valide et si c'est le jeton de l'admin
exports.checkAuthAdmin = (req, res, next) => {
  if (checkAdmin(req) == false) {
    return res.status(401).send("Check your privileges");
  }
  if (req.headers.authorization) {
    const token = req.headers.authorization.split(" ")[1];
    try {
      // Verifie le token avec la clef secrète
      const decoded = jwt.verify(token, process.env.SUPABASE_TOKEN);
      req.userData = decoded;
      // S'il est possible de le decoder alors on passe au prochains middleware
      next();
    } catch (err) {
      return res.status(401).json({
        message: "Auth failed",
        err,
      });
    }
  } else {
    res.status(401);
  }
  next();
};

// CREATION
exports.postItem = async (req, res) => {
  const jsonData = req.body;
  if (jsonData.archived) {
    return res
      .status(403)
      .send(
        "Interdit : les items ne peuvent pas être créés et archivés en même temps"
      );
  } else {
    const { data, error } = await supabaseAd.from("ITEM").insert([jsonData]);

    if (error) {
      // console.log(req)
      return res
        .status(500)
        .send("Erreur lors de l'enregistrement des données dans Supabase.");
    }

    return res.send(
      "Données enregistrées avec succès dans Supabase. Nouveau meuble ajouté dans le BackOffice."
    );
  }
};

// MODIFICATION
exports.editItem = async (req, res) => {
  const jsonData = req.body;
  if (jsonData.archived) {
    return res
      .status(403)
      .send(
        "Interdit : les items ne peuvent pas être modifiés et archivés en même temps"
      );
  } else {
    const { data, error } = await supabaseAd
      .from("ITEM")
      .update([jsonData])
      .eq("id", jsonData.id);

    if (error) {
      return res.status(403)
        .send(`Echec de la modification de l'item (nom :'${jsonData.name}', prix :'${jsonData.price}'), Supabase_error: ${error.message}
      `);
    }

    return res
      .status(201)
      .send(
        "Données enregistrées avec succès. Item modifié : " + jsonData.name
      );
  }
};

// ARCHIVAGE
exports.archiveItem = async (req, res) => {
  const jsonData = req.body;

  const { data, error } = await supabaseAd
    .from("ITEM")
    .update([jsonData])
    .eq("id", jsonData.id);
  if (!jsonData.archived) {
    return res.status(403).send("La propriété 'archived' doit être modifiée");
  } else {
    if (error) {
      return res.status(404)
        .send(`Echec de l'archivage de l'item, assurez-vous de ne modifier que la propriété "archived"
       (nom :'${jsonData.name}',
       prix :'${jsonData.price}'),
      Supabase_error: ${error.message}
      `);
    }

    return res
      .status(201)
      .send("Données enregistrées avec succès. Archivé : " + jsonData.name);
  }
};

// SUPPRESSION (Work In Progress :update or delete on table "ITEM" violates foreign key constraint
//"ITEM_COLOR_RELA_item_id_fkey" on table "ITEM_COLOR_RELA")
exports.deleteItem = async (req, res) => {
  const jsonData = req.body;

  if (!jsonData.archived) {
    return res
      .status(403)
      .send("Interdit : les items doivent être archivés avant suppression");
  } else {
    const { data, error } = await supabaseAd
      .from("ITEM")
      .delete([jsonData])
      .eq("id", jsonData.id);

    if (error) {
      return res.status(404)
        .send(`Echec de la suppression de l'item (nom :'${jsonData.name}', prix :'${jsonData.price}'), Supabase_error: ${error.message}
      `);
    }

    return res
      .status(201)
      .send(
        "Données enregistrées avec succès. Item supprimé : " + jsonData.name
      );
  }
};

// CREATE COLOR
exports.postColor = async (req, res) => {
  const jsonData = req.body;

  const { data, error } = await supabase.from("COLOR").insert([jsonData]);

  if (error) {
    return res
      .status(500)
      .send("Erreur lors de l'enregistrement des données dans Supabase.");
  }

  return res.send(
    "Données enregistrées avec succès dans Supabase. Nouvelle couleur ajoutée dans le BackOffice."
  );
};

// CREATE CAT
exports.postCategory = async (req, res) => {
  const jsonData = req.body;

  const { data, error } = await supabase.from("CATEG").insert([jsonData]);

  if (error) {
    return res
      .status(500)
      .send("Erreur lors de l'enregistrement des données dans Supabase.");
  }

  return res.send(
    "Données enregistrées avec succès dans Supabase. Nouvelle catégorie ajoutée dans le BackOffice."
  );
};

// CREATE SUB_CAT
exports.postSubcategory = async (req, res) => {
  const jsonData = req.body;

  const { data, error } = await supabase.from("SUB_CATEG").insert([jsonData]);

  if (error) {
    return res
      .status(500)
      .send("Erreur lors de l'enregistrement des données dans Supabase.");
  }

  return res.send(
    "Données enregistrées avec succès dans Supabase. Nouvelle sous-catégorie ajoutée dans le BackOffice."
  );
};

function checkAdmin(req) {
  // Verifie si l'user enregeristré dans le jeton JWT correspond a l'Admin
  if (!req.userData) {
    return false;
  }
  if (req.userData.sub == "2e0ab73d-47b8-4ee2-8f43-e22fe8a63dce") {
    return true;
  } else {
    return false;
  }
}
